# include <bits/stdc++.h>
# include "akari.h"
using namespace std;
namespace aka{
const int N = 250;
struct BlackAround{
    int x, y;
    bool flag;
};
struct BlackCell{
    int x, y;
};
vector<BlackAround> point;
vector<BlackCell> bcell;
vector<vector<int> > gg, ff;
bool vis[N][N], connect[N][N], light[15][15];
int n, m;
bool checking(int now)
{
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
        int dx = point[now].x + ps[i][0], dy = point[now].y + ps[i][1];
        if (dx >= 0 && dx < n && dy >= 0 && dy < m && gg[dx][dy] == 0) return false;
    }
    return true;
}
void do_undo(int now, int delta)
{
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
        int dx = point[now].x + ps[i][0], dy = point[now].y + ps[i][1];
        if (dx >= 0 && dx < n && dy >= 0 && dy < m && gg[dx][dy] >= 0) gg[dx][dy] += delta;
    }
}
bool check(int x, int y) {
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
        int dx = x + ps[i][0], dy = y + ps[i][1];
        if (dx >= 0 && dx < n && dy >= 0 && dy < m && ff[dx][dy] >= 0) return false;
    }
    for (int k = x + 1; k < n; ++k) {
        if (light[k][y] == true) return false;
        if (ff[k][y] != -2) break;
    }
    for (int k = x - 1; k >= 0; --k) {
        if (light[k][y] == true) return false;
        if (ff[k][y] != -2) break;
    }
    for (int k = y + 1; k < m; ++k) {
        if (light[x][k] == true) return false;
        if (ff[x][k] != -2) break;
    }
    for (int k = y - 1; k >= 0; --k) {
        if (light[x][k] == true) return false;
        if (ff[x][k] != -2) break;
    }
    return true;
}
bool determine_light_cell (int x, int y)
{
    if (x == n) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (ff[i][j] != -2 || light[i][j] == true) continue;
                bool mark = false;
                for (int k = i + 1; k < n; ++k) {
                    if (light[k][j] == true) {mark = true; break;}
                    if (ff[k][j] != -2) break;
                }
                if (mark == true) continue;
                for (int k = i - 1; k >= 0; --k) {
                    if (light[k][j] == true) {mark = true; break;}
                    if (ff[k][j] != -2) break;
                }
                if (mark == true) continue;
                for (int k = j + 1; k < m; ++k) {
                    if (light[i][k] == true) {mark = true; break;}
                    if (ff[i][k] != -2) break;
                }
                if (mark == true) continue;
                for (int k = j - 1; k >= 0; --k) {
                    if (light[i][k] == true) {mark = true; break;}
                    if (ff[i][k] != -2) break;
                }
                if (mark == false) return false;
            }
        }
        return true;
    }
    if (light[x][y] == true || ff[x][y] != -2) {
        return determine_light_cell(y == m - 1 ? x + 1 : x, y == m - 1 ? 0 : y + 1);
    }
    else {
       if (check(x, y) == true) {
            light[x][y] = true;
            if (determine_light_cell(y == m - 1 ? x + 1 : x, y == m - 1 ? 0 : y + 1) == true)
                return true;
            light[x][y] = false;
       }
       return determine_light_cell(y == m - 1 ? x + 1 : x, y == m - 1 ? 0 : y + 1);
    }
}
bool determine_black_cell_around(int now)
{
    if (now == (int)point.size()) {
        for (int i = 0; i < (int)bcell.size(); ++i) if (gg[bcell[i].x][bcell[i].y] != 0) return false;
        memset(light, false, sizeof(light));
        for (int i = 0; i < (int)point.size(); ++i) {
            if (point[i].flag == true) light[point[i].x][point[i].y] = true;
        }
        bool flag = determine_light_cell(0, 0);
        return flag;
    }
    if (checking(now)) {
        bool mark = false;
        for (int i = 0; i < now; ++i) {
            if (point[i].flag == true && connect[i][now] == true) {mark = true; break;}
        }
        if (mark == false) {
            point[now].flag = true;
            do_undo(now, -1);
            if (determine_black_cell_around(now + 1) == true) return true;
            point[now].flag = false;
            do_undo(now, 1);
        }
    }
    return determine_black_cell_around(now + 1);
}
vector<vector<int> >  solveAkari(vector<vector<int> > & g)
{
    // 请在此函数内返回最后求得的结果
    n = (int)g.size(); m = (int)g[0].size();
    int ps[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    for (int i = 0; i < n; ++i) {
        gg.push_back(vector<int>()); ff.push_back(vector<int>());
        for (int j = 0; j < m; ++j) {
            gg[i].push_back(g[i][j]); ff[i].push_back(g[i][j]);
            if (g[i][j] >= 0 && g[i][j] <= 4) {
                bcell.push_back(BlackCell{i, j});
                for (int k = 0; k < 4; ++k) {
                    int dx = i + ps[k][0], dy = j + ps[k][1];
                    if (dx >= 0 && dx < n && dy >= 0 && dy < m && g[dx][dy] == -2 && vis[dx][dy] == false) {
                        point.push_back(BlackAround{dx, dy, false});
                        vis[dx][dy] = true;
                    }
                }
            }
        }
    }
    int siz = (int)point.size();
    for (int i = 0; i < siz; ++i) {
        for (int j = i + 1; j < siz; ++j) {
            if (point[i].x == point[j].x) {
                bool mark = false;
                for (int k = min(point[i].y, point[j].y)+1; k <= max(point[i].y, point[j].y)-1; ++k) {
                    if (gg[point[i].x][k] >= -1) {mark = true; break;}
                }
                if (mark == false) connect[i][j] = true;
            }
            else if (point[i].y == point[j].y) {
                bool mark = false;
                for (int k = min(point[i].x, point[j].x)+1; k <= max(point[i].x, point[j].x)-1; ++k) {
                    if (gg[k][point[i].y] >= -1) {mark = true; break;}
                }
                if (mark == false) connect[i][j] = true;
            }
        }
    }
    determine_black_cell_around(0);
    for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) if (light[i][j] == true) ff[i][j] = 5;
    return ff;
}
}